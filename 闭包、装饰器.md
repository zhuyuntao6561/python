# python
### 闭包

* 内部函数调用外部函数的变量(一个闭包就是你调用的一个函数A，这个函数A返回一个函数B给你。这个返回的函数B就叫做闭包)

* 优点：可以提高代码的可复用性，减少了代码的可移植性

* 特点：一个独立的空间，多个闭包互补影响，占用空间远小于实例对象；

* 注意点：引用了外部函数的局部变量，则外部函数的局部变量没有及时释放，消耗内存

* nonlocal 修改一个函数内部变量时使用

```
# 定义一个函数
def test(number):
        
        # 在函数内部再定义一个函数，并且这个函数用到了外边函数的变量，那么将这个函数及用到的一些变量称之为闭包
        def test_in(number_in):
                print("in text_in 函数, number_in is %d" % number_in)
                return number + number_in
        # 其实这里返回的就是闭包的结果
        return text_in
# 给test函数赋值，这个20就是给参数number
ret = test(20)
# 注意这里的100其实给参数的number_in
print(ret(100))
# 注意这里的200其实给参数number_in
print(ret(200))

运行结果：
in test_in 函数, number_in is 100
120
in test_in 函数, number_in is 200
220
```


### 装饰器

* 定义一个函数，在运行时动态增加功能 

* 在不修改原函数的代码的情况下，添加新的功能，可以在执行原函数之前加，也可以在执行原函数之后添加
* 注意点：
    - 装饰器只能在调用原函数之前或之后添加功能，而不能在函数的中间添加功能
    - 只要用装饰器装饰了的函数，那么不管被调用多少次，都是装饰之后的效果

* 装饰器（decorator）功能
   1.引入日志
   2.函数执行时间统计
   3.执行函数前预备处理
   4.执行函数后清理功能
   5.权限校验等场景
   6.缓存


```
#### 第一波 ####
def foo()
       print("foo")
foo # 表示是函数
foo() # 表示执行foo函数
#### 第二波 ####
def foo()
       print("foo")

foo = lambda x: x + 1
foo() # 执行lambda表达式， 而不再是原来的foo函数， 因为foo这个名字被重新指向另外一个匿名函数
```
* 写代码要遵循开放封闭原则，它规定已经实现的功能代码不允许被修改，但可以被扩展
        - 封闭：对实现功能的代码块
        - 开放：扩展开发 

* 一般情况下为了让装饰器更通用，可以有return
* 装饰的时候：谁离被装饰的函数越近，那么就先装谁
* 调用的时候：谁离的远，那么先调谁
